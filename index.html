<!DOCTYPE html>
<html>
<head>
    <title>Game Maker Tilemap collision</title>
    <meta charset="utf-8">
    <style type="text/css">
        body {
            background-color: #f5f2ec;
            margin-bottom: 100px;
            font-family: sans-serif;
            color: #333333;
        }
        .caption {
            position: fixed;
            bottom: 0;
            right: 0;
            left: 0;
            box-shadow: 0 0 5px 5px #cbcbcb;
            background-color: #f4e9dc;
            padding: 5px;
        }
        .caption>div {
            display: inline-block;
            margin-right: 15px;
        }
        .use-case {
            display: flex;
            flex-wrap: wrap;
            border-bottom: 1px solid #cbcbcb;
            padding-top: 10px;
            padding-bottom: 10px;
        }
        .use-case>div {
            width: 100%;
        }
        .report-status {
            font-size: 1.8rem;
            font-weight: bold;
            text-align: center;
        }
        .success {
            color: #4be12d;
        }
        .fail {
            color: #eb1c1c;
        }
        .canvas-container {
            text-align: center;
            overflow-x: auto;
        }
        footer {
            padding: 20px;
            text-align: right;
        }
        @media only screen and (min-width: 1080px) {
            .caption {
                left: 50%;
                right: auto;
            }
            .use-case>div {
                width: 50%;
            }
            .report {
                position: relative;
            }
            .report-status {
                text-align: right;
                position: absolute;
                bottom: 0;
                right: 20px;
            }
            .canvas-container {
                text-align: left;
            }
        }
    </style>
</head>
<body>

<h1>GameMaker Tilemap Collision Use Cases</h1>

<p>
    Collision testing.
</p>

<div id="useCases"></div>

<div class="caption">
    <div>
        <span>Start</span> <canvas id="playerCaptionCanvas"></canvas>
    </div>
    <div>
        <span>Tried</span> <canvas id="triedCaptionCanvas"></canvas>
    </div>
    <div>
        <span>Expected</span> <canvas id="expectedCaptionCanvas"></canvas>
    </div>
    <div>
        <span>Final</span> <canvas id="finalCaptionCanvas"></canvas>
    </div>
    <div>
        <span>Collision Tile</span> <canvas id="collisionTileCaptionCanvas"></canvas>
    </div>
</div>

<footer>By Benjamin Hacques</footer>


<script type="application/javascript">

var tile_size = 64;
var tilemap = 'Collisions'; // just to get a parameter like the GML tilemap_get_at_pixel function
var room_width = 10000;
var room_height = 10000;

var zoom = 0; // 0 = default, 2 = zoom, -2 = unzoom (from -infinite to +infinite, float allowed)
var use_case_count = 0; // the use case number for debug purpose

/**
 * The player need to move. He knows the direction, we must find if there is no collision tile on his way.
 * This function is meant to be use as a script in GameMaker using GML so you can only use the parameters.
 * @param {int} x - Current player x.
 * @param {int} y - Current player y.
 * @param {int} xx - Delta between current x and where the player tries to go.
 * @param {int} yy - Delta between current y and where the player tries to go.
 * @param {int} bbox_left - X coordinate of the left side of the bbox.
 * @param {int} bbox_top - Y coordinate of the top side of the bbox.
 * @param {int} bbox_right - X coordinate of the right side of the bbox.
 * @param {int} bbox_bottom - Y coordinate of the bottom side of the bbox.
 * @param {function(any, int, int):int} tilemap_get_at_pixel - Same as GameMaker's one.
 *     Parameters are :
 *         {any} tilemap_element_id - Useless in this js script but we keep the same parameters as GML tilemap_get_at_pixel().
 *         {int} x
 *         {int} y
 *     Return value is 1 if there is a tile at these coordinates else 0.
 * @returns {number[]} - Valid new position after collision check. Like this : [valid_x, valid_y]
 */
function getValidPosition(x, y, xx, yy, bbox_left, bbox_top, bbox_right, bbox_bottom, tilemap_get_at_pixel, tile_size, room_width, room_height) {

	//return [x+xx, y+yy]
	//if (use_case_count === 5) {console.log(next_bottom_point);return;}
	//if (use_case_count === 5) {console.log(next_bottom_point);}

	/**
	 * [JS ONLY]
	 * native gamemaker function
	 */
	var clamp = function(val, min, max) {
		if (val < min) return min;
		if (val > max) return max;
		return val;
	}

	var scr_get_x_on_segment = function(...argument) {
		/// @description scr_get_x_on_segment
		/// @param {number} y
		/// @param {number} point1_x
		/// @param {number} point1_y
		/// @param {number} point2_x
		/// @param {number} point2_y
		/// @returns {number} x
		/// @see https://math.stackexchange.com/questions/2297518/

		// if point1_x == point2_x return point1_x
		if (argument[1] == argument[3]) return argument[1];
		// return point1_x + ( ( (y - point1_y) * (point2_x - point1_x) ) / (point2_y - point1_y) );
		return argument[1] + ( ( (argument[0] - argument[2]) * (argument[3] - argument[1]) ) / (argument[4] - argument[2]) );
	}

	var scr_get_y_on_segment = function(argument0, argument1, argument2, argument3, argument4) {
		/// @description scr_get_y_on_segment
		/// @param {number} x
		/// @param {number} point1_x
		/// @param {number} point1_y
		/// @param {number} point2_x
		/// @param {number} point2_y
		/// @returns {number} y
		/// @see https://math.stackexchange.com/questions/2297518/

		// if point1_y == point2_y return point1_y
		if (argument2 == argument4) return argument2;
		// return point1_y + ( ( (x - point1_x) * (point2_y - point1_y) ) / (point2_x - point1_x) );
		return argument2 + ( ( (argument0 - argument1) * (argument4 - argument2) ) / (argument3 - argument1) );
	}

	var scr_find_closest_valid_position = function(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8, argument9, argument10) {
		/// @description scr_find_closest_valid_position
		/// The object must use abstr_physical
		/// @param {number} x
		/// @param {number} y
		/// @param {number} xx
		/// @param {number} yy
		/// @param {number} bbox_left
		/// @param {number} bbox_top
		/// @param {number} bbox_right
		/// @param {number} bbox_bottom
		/// @param {number} tile_size
		/// @param {number} collision_tilemap
		/// @param {number} collision_tile_id
		/// @returns {array} [x, y, on_ground_or_roof, on_wall] 

		var _x = argument0;
		var _y = argument1;
		var _xx = argument2;
		var _yy = argument3;
		var _bbox_left = argument4;
		var _bbox_top = argument5;
		var _bbox_right = argument6;
		var _bbox_bottom = argument7;
		var _tile_size = argument8;
		var _collision_tilemap = argument9;
		var _collision_tile_id = argument10;

		// xside = left or right side
		// yside = bottom or top side
		var _front_bbox_xside, _front_bbox_yside,	// bbox sides facing object movement direction
			_tried_bbox_xside, _tried_bbox_yside,	// bbox of the object at the tried location
			_next_tile_xdist, _next_tile_ydist,		// distance to got to the next tile for a point on the top left corner of a tile (depending on the object movement direction)
			_xside_sign, _yside_sign,				// 1 = to the right/bottom, -1 = to the left/top
			_xside_offset, _yside_offset;			// distance between (x,y) point and the bbox side facing the direction

		if (_xx >= 0) {
		    // to the right or no horizontal movement
		    _front_bbox_xside = _bbox_right;
		    _next_tile_xdist = _tile_size;
		    _xside_sign = 1;
		    _xside_offset = _bbox_right - _x;
		} else {
		    // to the left
		    _front_bbox_xside = _bbox_left;
		    _next_tile_xdist = -1;
		    _xside_sign = -1;
		    _xside_offset = _x - _bbox_left;
		}
		_tried_bbox_xside = clamp(_front_bbox_xside + _xx, 0, room_width - 1);

		if (_yy >= 0) {
		    // to the bottom or no vertical movement
		    _front_bbox_yside = _bbox_bottom;
		    _next_tile_ydist = _tile_size;
		    _yside_sign = 1;
		    _yside_offset = _bbox_bottom - _y;
		} else {
		    // to the top
		    _front_bbox_yside = _bbox_top;
		    _next_tile_ydist = -1;
		    _yside_sign = -1;
		    _yside_offset = _y - _bbox_top;
		}
		_tried_bbox_yside = clamp(_front_bbox_yside + _yy, 0, room_height - 1);

		var _closest_corner_position = _scr_find_closest_valid_corner_position(
			_front_bbox_xside, _front_bbox_yside,
			_tried_bbox_xside, _tried_bbox_yside,
			_xx, _yy,
			_next_tile_xdist, _next_tile_ydist,
			_xside_sign, _yside_sign,
			_bbox_left, _bbox_top, _bbox_right, _bbox_bottom,
			_tile_size, _collision_tilemap, _collision_tile_id
		);

		return [_closest_corner_position[0] - (_xside_offset * _xside_sign), _closest_corner_position[1] - (_yside_offset * _yside_sign), _closest_corner_position[2], _closest_corner_position[3]];
	}

	var _scr_find_closest_valid_corner_position = function(...argument) {
		/// @description _scr_find_closest_valid_corner_position - Use scr_check_collision
		/// @param {number} _curr_bbox_xside
		/// @param {number} _curr_bbox_yside
		/// @param {number} _tried_bbox_xside
		/// @param {number} _tried_bbox_yside
		/// @param {number} _xx
		/// @param {number} _yy
		/// @param {number} _next_tile_xdist
		/// @param {number} _next_tile_ydist
		/// @param {number} _xside_sign
		/// @param {number} _yside_sign
		/// @param {number} _bbox_left
		/// @param {number} _bbox_top
		/// @param {number} _bbox_right
		/// @param {number} _bbox_bottom
		/// @param {number} _tile_size
		/// @param {number} _collision_tilemap
		/// @param {number} _collision_tile_id
		/// @returns {array} [safe_x, safe_y, on_ground_or_roof, on_wall] 
			
		var _curr_bbox_xside = argument[0];
		var _curr_bbox_yside = argument[1];
		var _tried_bbox_xside = argument[2];
		var _tried_bbox_yside = argument[3];
		var _xx = argument[4];
		var _yy = argument[5];
		var _next_tile_xdist = argument[6];
		var _next_tile_ydist = argument[7];
		var _xside_sign = argument[8];
		var _yside_sign = argument[9];
		var _bbox_left = argument[10];
		var _bbox_top = argument[11];
		var _bbox_right = argument[12];
		var _bbox_bottom = argument[13];
		var _tile_size = argument[14];
		var _collision_tilemap = argument[15];
		var _collision_tile_id = argument[16];
			
		var _curr_tile_bbox_left = _curr_bbox_xside - (_curr_bbox_xside % _tile_size);
		var _curr_tile_bbox_top = _curr_bbox_yside - (_curr_bbox_yside % _tile_size);

		// next tiles the object corners will cross
		var _next_wall_x = _curr_tile_bbox_left + _next_tile_xdist;
		var _next_wall_y = _curr_tile_bbox_top + _next_tile_ydist;

		// points where object will enter new tiles
		var _next_xside_point_x, _next_xside_point_y, _next_yside_point_x, _next_yside_point_y;
		var _next_xside_point_is_defined = false;
		var _next_yside_point_is_defined = false;

		// si tried_bbox_xside ne dépasse pas next_wall_x c'est qu'on ne change pas de tile sur l'axe x donc on a rien a check pour les cotés droit ou gauche
		if ((_xx > 0 && _next_wall_x - 1 < _tried_bbox_xside) || (_xx < 0 && _next_wall_x + 1 > _tried_bbox_xside)) {
		    _next_xside_point_x = _next_wall_x;
			_next_xside_point_y = scr_get_y_on_segment(_next_xside_point_x, _curr_bbox_xside, _curr_bbox_yside, _tried_bbox_xside, _tried_bbox_yside);
			_next_xside_point_is_defined = true;
		}

		if ((_yy > 0 && _next_wall_y - 1 < _tried_bbox_yside) || (_yy < 0 && _next_wall_y + 1 > _tried_bbox_yside)) {
			_next_yside_point_y = _next_wall_y;
		    _next_yside_point_x = scr_get_x_on_segment(_next_yside_point_y, _curr_bbox_xside, _curr_bbox_yside, _tried_bbox_xside, _tried_bbox_yside);
			_next_yside_point_is_defined = true;
		}

		var _next_point_x, _next_point_y, _next_safe_point_x, _next_safe_point_y, _next_point_side;

		if (_next_xside_point_is_defined && !_next_yside_point_is_defined) {
		    _next_point_x = _next_xside_point_x;
		    _next_point_y = _next_xside_point_y;
		    _next_point_side = "xside";
		    _next_safe_point_x = _next_point_x - _xside_sign;
			_next_safe_point_y = scr_get_y_on_segment(_next_safe_point_x, _curr_bbox_xside, _curr_bbox_yside, _tried_bbox_xside, _tried_bbox_yside);

		} else if (!_next_xside_point_is_defined && _next_yside_point_is_defined) {
		    _next_point_x = _next_yside_point_x;
		    _next_point_y = _next_yside_point_y;
		    _next_point_side = "yside";
			_next_safe_point_y = _next_point_y - _yside_sign;
		    _next_safe_point_x = scr_get_x_on_segment(_next_safe_point_y, _curr_bbox_xside, _curr_bbox_yside, _tried_bbox_xside, _tried_bbox_yside);

		} else if (_next_xside_point_is_defined && _next_yside_point_is_defined) {
		            // next_point = point in an adjacent tile
		    if (_next_xside_point_x - _next_tile_xdist == _curr_tile_bbox_left && _next_xside_point_y - (_next_xside_point_y % _tile_size) == _curr_tile_bbox_top) {
				_next_point_x = _next_xside_point_x;
				_next_point_y = _next_xside_point_y;
				_next_point_side = "xside";
				_next_safe_point_x = _next_point_x - _xside_sign;
				_next_safe_point_y = scr_get_y_on_segment(_next_safe_point_x, _curr_bbox_xside, _curr_bbox_yside, _tried_bbox_xside, _tried_bbox_yside);

		    } else if (_next_yside_point_y - _next_tile_ydist == _curr_tile_bbox_top && _next_yside_point_x - (_next_yside_point_x % _tile_size) == _curr_tile_bbox_left) {
			    _next_point_x = _next_yside_point_x;
			    _next_point_y = _next_yside_point_y;
			    _next_point_side = "yside";
				_next_safe_point_y = _next_point_y - _yside_sign;
			    _next_safe_point_x = scr_get_x_on_segment(_next_safe_point_y, _curr_bbox_xside, _curr_bbox_yside, _tried_bbox_xside, _tried_bbox_yside);

		    } else {
				// no adjacent tile = diagonal tile = next_xside_point and next_yside_point are equal
				_next_point_x = _next_xside_point_x;
				_next_point_y = _next_xside_point_y;
				_next_point_side = "both";
				_next_safe_point_x = _next_point_x - _xside_sign;
				_next_safe_point_y = scr_get_y_on_segment(_next_safe_point_x, _curr_bbox_xside, _curr_bbox_yside, _tried_bbox_xside, _tried_bbox_yside);
		    }
			
		} else {
			// no collision + tried position reached
			return [_tried_bbox_xside, _tried_bbox_yside, false, false];
		}

		// check main corner collision
		if (tilemap_get_at_pixel(_collision_tilemap, _next_point_x, _next_point_y) == _collision_tile_id) {
		    // collision = stop at safe position
			
			var _on_wall = _next_point_side == "xside" || _next_point_side == "both" ? true : false;
		    
			return [_next_safe_point_x, _next_safe_point_y, !_on_wall, _on_wall];
		}

		var _is_same_tile;
		// check other corners
		if (_next_point_side == "yside" || _next_point_side == "both") {
			var _other_corner_x = _next_point_x + ( (_bbox_right - _bbox_left) * -_xside_sign );
			var _other_corner_y = _next_point_y;
			_is_same_tile = false;
		    if (_next_point_side == "yside") {
		        // lighter
		        _is_same_tile = _curr_tile_bbox_left <= _other_corner_x && _other_corner_x < _curr_tile_bbox_left + _tile_size;
		    } else {
		        var _next_point_tile_x = _next_point_x - (_next_point_x % _tile_size);
		        _is_same_tile = _next_point_tile_x <= _other_corner_x && _other_corner_x < _next_point_tile_x + _tile_size;
		    }
		    if (!_is_same_tile) {
			    if (tilemap_get_at_pixel(_collision_tilemap, _other_corner_x, _other_corner_y) == _collision_tile_id) {
				    // collision = stop at safe position
				    return [_next_safe_point_x, _next_safe_point_y, _next_point_side == "yside", _next_point_side == "both"];
			    }
		    }
		}

		 if (_next_point_side == "xside" || _next_point_side == "both") {
			var _other_corner_x = _next_point_x;
			var _other_corner_y = _next_point_y + ( (_bbox_bottom - _bbox_top) * -_yside_sign );
			_is_same_tile = false;
			if (_next_point_side == "xside") {
		        // lighter
		        _is_same_tile = _curr_tile_bbox_top <= _other_corner_y && _other_corner_y < _curr_tile_bbox_top + _tile_size;
		    } else {
		        var _next_point_tile_y = _next_point_y - (_next_point_y % _tile_size);
		        _is_same_tile = _next_point_tile_y <= _other_corner_y && _other_corner_y < _next_point_tile_y + _tile_size;
		    }
		    if (!_is_same_tile) {
			    if (tilemap_get_at_pixel(_collision_tilemap, _other_corner_x, _other_corner_y) == _collision_tile_id) {
				    // collision = stop at safe position
				    return [_next_safe_point_x, _next_safe_point_y, false, true];
			    }
			}
		}

		return _scr_find_closest_valid_corner_position(
			_next_point_x, _next_point_y,
			argument[2], argument[3], argument[4], argument[5], argument[6], argument[7], argument[8], argument[9],
			argument[10], argument[11], argument[12], argument[13], argument[14], argument[15], argument[16]);
	}

	var new_pos = scr_find_closest_valid_position(
		x, y,
		xx, yy,
		bbox_left, bbox_top, bbox_right, bbox_bottom,
		tile_size, tilemap, 1
	);
	x = new_pos[0];
	y = new_pos[1];
	on_ground = new_pos[2];
	on_wall = new_pos[3];

	return [x, y];
}

/**
 * All use cases.
 */
function test() {

    ///////// DIRECTION = NO DIRECTION
    var descr_direction = 'not moving';

    var start = makePlayerFromTopLeft(tile_size + 5, tile_size + 5);
    var tried = start;
    var expect = tried;
    addUseCase(
        start,
        [],
        tried,
        expect,
        descr_direction
    );

    ///////// DIRECTION = BOTTOM RIGHT
    var descr_direction = 'to bottom right';

    // simple inside a tile
    var description = concatLB(descr_direction, 'inside 1 tile');

    var start = makePlayerFromTopLeft(tile_size + 5, tile_size + 5);
    var tried = makePlayerFromTopLeft(tile_size + 10, tile_size + 10);
    var expect = tried;
    addUseCase(
        start,
        [],
        tried,
        expect,
        description
    );

    zoom = -0.5;
    var start = makePlayerFromTopLeft(tile_size + 5, tile_size + 5);
    var tried = makePlayerFromTopLeft(tile_size + 10, tile_size + 10);
    var expect = tried;
    addUseCase(
        start,
        [findTile(0,0), findTile(1,0), findTile(2,0), findTile(0,1), findTile(2,1), findTile(0,2), findTile(1,2), findTile(2,2)],
        tried,
        expect,
        description
    );
    zoom = 0;

    // simple move from 1 tile to 1 other
    var description = concatLB(descr_direction, '1 tile to 1 other');

    var start = makePlayerFromBottomLeft(tile_size + 3, tile_size - 5);
    var tried = makePlayerFromBottomLeft(tile_size + 5, tile_size + 5);
    var expect = tried;
    addUseCase(
        start,
        [],
        tried,
        expect,
        description
    );

    var tile = findTile(1,1);
    var start = makePlayerFromBottomLeft(tile.x_min + 3, tile.y_min - 5);
    var tried = makePlayerFromBottomLeft(tile.x_min + 5, tile.y_min + 5);
    var expect = makePlayerFromBottomLeft(getXOnSegment(tile.y_min - 1, new Position(start.bbox_left, start.bbox_bottom), new Position(tried.bbox_left, tried.bbox_bottom)), tile.y_min - 1);
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var tile = findTile(0,1);
    var start = makePlayerFromBottomLeft(tile_size + 3, tile_size - 5);
    var tried = makePlayerFromBottomLeft(tile_size + 5, tile_size + 5);
    var expect = tried;
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var tile = findTile(1,1);
    var start = makePlayerFromTopRight(tile.x_min - 3, tile.y_min + 5);
    var tried = makePlayerFromTopRight(tile.x_min + 5, tile.y_min + 10);
    var expect = makePlayerFromTopRight(tile.x_min - 1, getYOnSegment(tile.x_min - 1, new Position(start.bbox_right, start.bbox_top), new Position(tried.bbox_right, tried.bbox_top)));
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );


    // simple move from 2 tiles to 1 other not crossing other tiles
    var description = concatLB(descr_direction, '2 tiles to 1 other, NOT crossing other tiles');

    var start = makePlayerFromBottomLeft(tile_size - 3, tile_size - 5);
    var tried = makePlayerFromBottomLeft(tile_size + 5, tile_size + 3);
    var expect = tried;
    addUseCase(
        start,
        [],
        tried,
        expect,
        description
    );

    var tile = findTile(1,1);
    var start = makePlayerFromBottomLeft(tile.x_min - 3, tile.y_min - 5);
    var tried = makePlayerFromBottomLeft(tile.x_min + 5, tile.y_min + 3);
    var expect = makePlayerFromBottomLeft(getXOnSegment(tile.y_min - 1, new Position(start.bbox_left, start.bbox_bottom), new Position(tried.bbox_left, tried.bbox_bottom)), tile.y_min - 1);
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var tile = findTile(0,1);
    var start = makePlayerFromBottomLeft(tile_size - 3, tile_size - 5);
    var tried = makePlayerFromBottomLeft(tile_size + 5, tile_size + 3);
    var expect = tried;
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var tile = findTile(1,1);
    var start = makePlayerFromBottomLeft(tile.x_min - 3, tile.y_min - 5);
    var tried = makePlayerFromBottomLeft(tile.x_min + 5, tile.y_min + 3);
    var expect = makePlayerFromBottomLeft(getXOnSegment(tile.y_min - 1, new Position(start.bbox_left, start.bbox_bottom), new Position(tried.bbox_left, tried.bbox_bottom)), tile.y_min - 1);
    addUseCase(
        start,
        [findTile(0,1), tile],
        tried,
        expect,
        description
    );


    // simple move from 2 tiles to 1 other crossing other tiles
    var description = concatLB(descr_direction, '2 tiles to 1 other, CROSSING other tile');

    var start = makePlayerFromBottomLeft(tile_size - 8, tile_size - 3);
    var tried = makePlayerFromBottomLeft(tile_size + 3, tile_size + 8);
    var expect = tried;
    addUseCase(
        start,
        [],
        tried,
        expect,
        description
    );

    var tile = findTile(1,1);
    var start = makePlayerFromBottomLeft(tile.x_min - 8, tile.y_min - 3);
    var tried = makePlayerFromBottomLeft(tile.x_min + 3, tile.y_min + 8);
    var expect = makePlayerFromBottomLeft(getXOnSegment(tile.y_min - 1, new Position(start.bbox_left, start.bbox_bottom), new Position(tried.bbox_left, tried.bbox_bottom)), tile.y_min - 1);
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var tile = findTile(0,1);
    var start = makePlayerFromBottomLeft(tile_size - 8, tile_size - 3);
    var tried = makePlayerFromBottomLeft(tile_size + 3, tile_size + 8);
    var expect = makePlayerFromBottomLeft(getXOnSegment(tile_size - 1, new Position(start.bbox_left, start.bbox_bottom), new Position(tried.bbox_left, tried.bbox_bottom)), tile_size - 1);
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var tile = findTile(1,1);
    var start = makePlayerFromTopRight(tile.x_min - 3, tile.y_max - 8);
    var tried = makePlayerFromTopRight(tile.x_min + 8, tile.y_max + 3);
    var expect = makePlayerFromTopRight(tile.x_min - 1, getYOnSegment(tile.x_min - 1, new Position(start.bbox_right, start.bbox_top), new Position(tried.bbox_right, tried.bbox_top)));
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var tile = findTile(1,1);
    var start = makePlayerFromBottomLeft(tile.x_min - 8, tile.y_min - 3);
    var tried = makePlayerFromBottomLeft(tile.x_min + 3, tile.y_min + 8);
    var expect = makePlayerFromBottomLeft(getXOnSegment(tile.y_min - 1, new Position(start.bbox_left, start.bbox_bottom), new Position(tried.bbox_left, tried.bbox_bottom)), tile.y_min - 1);
    addUseCase(
        start,
        [findTile(0,1), tile],
        tried,
        expect,
        description
    );


    // simple move from 4 tiles to 1
    var description = concatLB(descr_direction, '4 tiles to 1');

    var start = makePlayerFromTopLeft(tile_size - 5, tile_size - 5);
    var tried = makePlayerFromTopLeft(tile_size + 5, tile_size + 5);
    var expect = tried;
    addUseCase(
        start,
        [],
        tried,
        expect,
        description
    );

    var start = makePlayerFromTopLeft(tile_size - 5, tile_size - 5);
    var tried = makePlayerFromTopLeft(tile_size + 5, tile_size + 5);
    var expect = tried;
    addUseCase(
        start,
        [findTile(1,2)],
        tried,
        expect,
        description
    );

    var start = makePlayerFromTopLeft(tile_size - 5, tile_size - 5);
    var tried = makePlayerFromTopLeft(tile_size + 5, tile_size + 5);
    var expect = tried;
    addUseCase(
        start,
        [findTile(0,2)],
        tried,
        expect,
        description
    );

    zoom = -0.5;
    var start = makePlayerFromTopLeft(tile_size - 5, tile_size - 5);
    var tried = makePlayerFromTopLeft(tile_size + 5, tile_size + 5);
    var expect = tried;
    addUseCase(
        start,
        [findTile(2,1)],
        tried,
        expect,
        description
    );
    zoom = 0;

    zoom = -0.5;
    var start = makePlayerFromTopLeft(tile_size - 5, tile_size - 5);
    var tried = makePlayerFromTopLeft(tile_size + 5, tile_size + 5);
    var expect = tried;
    addUseCase(
        start,
        [findTile(2,0)],
        tried,
        expect,
        description
    );
    zoom = 0;

    zoom = -0.5;
    var start = makePlayerFromTopLeft(tile_size - 5, tile_size - 5);
    var tried = makePlayerFromTopLeft(tile_size + 5, tile_size + 5);
    var expect = tried;
    addUseCase(
        start,
        [findTile(0,2), findTile(1,2), findTile(2,2), findTile(2,1), findTile(2,0)],
        tried,
        expect,
        description
    );
    zoom = 0;

    zoom = -1.5;
    var start = makePlayerFromTopLeft(tile_size - 5, tile_size - 5);
    var tried = makePlayerFromTopLeft(tile_size + 5, tile_size + 5);
    var expect = tried;
    addUseCase(
        start,
        [findTile(-1,-1), findTile(0,-1), findTile(1,-1), findTile(2,-1), findTile(-1,0), findTile(-1,1), findTile(-1,2), findTile(0,2), findTile(1,2), findTile(2,2), findTile(2,1), findTile(2,0)],
        tried,
        expect,
        concatLB(description, 'to be sure')
    );
    zoom = 0;


    // simple move from 4 tiles to 2
    var description = concatLB(descr_direction, '4 tiles to 2');

    var start = makePlayerFromTopLeft(tile_size - 10, tile_size - 5);
    var tried = makePlayerFromTopLeft(tile_size - 5, tile_size + 5);
    var expect = tried;
    addUseCase(
        start,
        [],
        tried,
        expect,
        description
    );

    zoom = -1.5;
    var start = makePlayerFromTopLeft(tile_size - 10, tile_size - 5);
    var tried = makePlayerFromTopLeft(tile_size - 5, tile_size + 5);
    var expect = tried;
    addUseCase(
        start,
        [findTile(-1,-1), findTile(0,-1), findTile(1,-1), findTile(2,-1), findTile(-1,0), findTile(-1,1), findTile(-1,2), findTile(0,2), findTile(1,2), findTile(2,2), findTile(2,1), findTile(2,0)],
        tried,
        expect,
        concatLB(description)
    );
    zoom = 0;


    // simple move from 4 tiles to 4
    var description = concatLB(descr_direction, '4 tiles to 4');

    var start = makePlayerFromTopLeft(tile_size - 10, tile_size - 10);
    var tried = makePlayerFromTopLeft(tile_size - 5, tile_size - 5);
    var expect = tried;
    addUseCase(
        start,
        [],
        tried,
        expect,
        description
    );

    zoom = -1.5;
    var start = makePlayerFromTopLeft(tile_size - 10, tile_size - 10);
    var tried = makePlayerFromTopLeft(tile_size - 5, tile_size - 5);
    var expect = tried;
    addUseCase(
        start,
        [findTile(-1,-1), findTile(0,-1), findTile(1,-1), findTile(2,-1), findTile(-1,0), findTile(-1,1), findTile(-1,2), findTile(0,2), findTile(1,2), findTile(2,2), findTile(2,1), findTile(2,0)],
        tried,
        expect,
        concatLB(description)
    );
    zoom = 0;


    // simple move from 1 tile to 2
    var description = concatLB(descr_direction, '1 tile to 2');

    var start = makePlayerFromBottomRight(tile_size * 2 - 20, tile_size - 2);
    var tried = makePlayerFromTopRight(tile_size * 2 + 2, tile_size + 10);
    var expect = tried;
    addUseCase(
        start,
        [],
        tried,
        expect,
        description
    );

    var tile = findTile(1,1);
    var start = makePlayerFromBottomRight(tile.x_max - 20, tile.y_min - 2);
    var tried = makePlayerFromTopRight(tile.x_max + 2, tile.y_min + 10);
    var expect = makePlayerFromBottomRight(getXOnSegment(tile.y_min - 1, new Position(start.bbox_right, start.bbox_bottom), new Position(tried.bbox_right, tried.bbox_bottom)), tile.y_min - 1);
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var tile = findTile(2,1);
    var start = makePlayerFromBottomRight(tile_size * 2 - 20, tile_size - 2);
    var tried = makePlayerFromTopRight(tile_size * 2 + 2, tile_size + 10);
    var expect = makePlayerFromBottomRight(tile.x_min - 1, getYOnSegment(tile.x_min - 1, new Position(start.bbox_right, start.bbox_bottom), new Position(tried.bbox_right, tried.bbox_bottom)));
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var tile = findTile(1,1);
    var start = makePlayerFromBottomRight(tile.x_max - 20, tile.y_min - 2);
    var tried = makePlayerFromTopRight(tile.x_max + 2, tile.y_min + 10);
    var expect = makePlayerFromBottomRight(getXOnSegment(tile.y_min - 1, new Position(start.bbox_right, start.bbox_bottom), new Position(tried.bbox_right, tried.bbox_bottom)), tile.y_min - 1);
    addUseCase(
        start,
        [tile, findTile(2,1)],
        tried,
        expect,
        description
    );

    var start = makePlayerFromBottomRight(tile_size * 2 - 20, tile_size - 2);
    var tried = makePlayerFromTopRight(tile_size * 2 + 2, tile_size + 10);
    var expect = tried;
    addUseCase(
        start,
        [findTile(2,0)],
        tried,
        expect,
        description
    );


    // simple move from 1 tile to 4
    var description = concatLB(descr_direction, '1 tile to 4');

    var start = makePlayerFromBottomRight(tile_size * 2 - 10, tile_size - 10);
    var tried = makePlayerFromBottomRight(tile_size * 2 + 5, tile_size + 15);
    var expect = tried;
    addUseCase(
        start,
        [],
        tried,
        expect,
        description
    );

    var tile = findTile(1,1);
    var start = makePlayerFromBottomRight(tile.x_max - 10, tile.y_min - 10);
    var tried = makePlayerFromBottomRight(tile.x_max + 5, tile.y_min + 15);
    var expect = makePlayerFromBottomRight(getXOnSegment(tile.y_min - 1, new Position(start.bbox_right, start.bbox_bottom), new Position(tried.bbox_right, tried.bbox_bottom)), tile.y_min - 1);
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var tile = findTile(2,1);
    var start = makePlayerFromBottomRight(tile_size * 2 - 5, tile_size - 5);
    var tried = makePlayerFromBottomRight(tile_size * 2 + 5, tile_size + 15);
    var expect = makePlayerFromBottomRight(tile_size * 2 - 1, getYOnSegment(tile_size * 2 - 1,  new Position(start.bbox_right, start.bbox_bottom), new Position(tried.bbox_right, tried.bbox_bottom)));
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var tile = findTile(2,1);
    var start = makePlayerFromBottomRight(tile_size * 2 - 10, tile_size - 5);
    var tried = makePlayerFromBottomRight(tile_size * 2 + 5, tile_size + 15);
    var expect = makePlayerFromBottomRight(tile.x_min - 1, getYOnSegment(tile_size * 2 - 1, new Position(start.bbox_right, start.bbox_bottom), new Position(tried.bbox_right, tried.bbox_bottom)));
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var tile = findTile(2,1);
    var start = makePlayerFromBottomRight(tile_size * 2 - 5, tile_size - 10);
    var tried = makePlayerFromBottomRight(tile_size * 2 + 10, tile_size + 15);
    var expect = makePlayerFromBottomRight(getXOnSegment(tile.y_min - 1, new Position(start.bbox_right, start.bbox_bottom), new Position(tried.bbox_right, tried.bbox_bottom)), tile.y_min - 1);
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var tile = findTile(2,0);
    var start = makePlayerFromBottomRight(tile_size * 2 - 10, tile_size - 10);
    var tried = makePlayerFromBottomRight(tile_size * 2 + 5, tile_size + 15);
    var expect = makePlayerFromBottomRight(tile.x_min - 1, getYOnSegment(tile.x_min - 1, new Position(start.bbox_right, start.bbox_bottom), new Position(tried.bbox_right, tried.bbox_bottom)));
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );


    // simple move from 1 tile to 4
    var description = concatLB(descr_direction, '1 tile to 4 (perfect angle)');

    var start = makePlayerFromBottomRight(tile_size * 2 - 10, tile_size - 10);
    var tried = makePlayerFromBottomRight(tile_size * 2 + 5, tile_size + 5);
    var expect = tried;
    addUseCase(
        start,
        [],
        tried,
        expect,
        description
    );

    var tile = findTile(1,1);
    var start = makePlayerFromBottomRight(tile.x_max - 10, tile.y_min - 10);
    var tried = makePlayerFromBottomRight(tile.x_max + 5, tile.y_min + 5);
    var expect = makePlayerFromBottomRight(getXOnSegment(tile.y_min - 1, new Position(start.bbox_right, start.bbox_bottom), new Position(tried.bbox_right, tried.bbox_bottom)), tile.y_min - 1);
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var tile = findTile(2,1);
    var start = makePlayerFromBottomRight(tile_size * 2 - 5, tile_size - 5);
    var tried = makePlayerFromBottomRight(tile_size * 2 + 5, tile_size + 5);
    var expect = makePlayerFromBottomRight(tile_size * 2 - 1, tile_size - 1);
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var tile = findTile(2,1);
    var start = makePlayerFromBottomRight(tile_size * 2 - 10, tile_size - 5);
    var tried = makePlayerFromBottomRight(tile_size * 2 + 5, tile_size + 10);
    var expect = makePlayerFromBottomRight(tile.x_min - 1, getYOnSegment(tile_size * 2 - 1, new Position(start.bbox_right, start.bbox_bottom), new Position(tried.bbox_right, tried.bbox_bottom)));
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var tile = findTile(2,1);
    var start = makePlayerFromBottomRight(tile_size * 2 - 5, tile_size - 10);
    var tried = makePlayerFromBottomRight(tile_size * 2 + 10, tile_size + 5);
    var expect = makePlayerFromBottomRight(getXOnSegment(tile.y_min - 1, new Position(start.bbox_right, start.bbox_bottom), new Position(tried.bbox_right, tried.bbox_bottom)), tile.y_min - 1);
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var tile = findTile(2,0);
    var start = makePlayerFromBottomRight(tile_size * 2 - 10, tile_size - 10);
    var tried = makePlayerFromBottomRight(tile_size * 2 + 5, tile_size + 5);
    var expect = makePlayerFromBottomRight(tile.x_min - 1, getYOnSegment(tile.x_min - 1, new Position(start.bbox_right, start.bbox_bottom), new Position(tried.bbox_right, tried.bbox_bottom)));
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var tile = findTile(2,0);
    var start = makePlayerFromBottomRight(tile_size * 2 - 10, tile_size - 10);
    var tried = makePlayerFromBottomRight(tile_size * 2 + 5, tile_size + 5);
    var expect = makePlayerFromBottomRight(tile.x_min - 1, getYOnSegment(tile.x_min - 1, new Position(start.bbox_right, start.bbox_bottom), new Position(tried.bbox_right, tried.bbox_bottom)));
    addUseCase(
        start,
        [tile, findTile(1,1)],
        tried,
        expect,
        description
    );

    ///////// DIRECTION = BOTTOM LEFT
    var descr_direction = 'to bottom left';

    var description = concatLB(descr_direction, 'inside 1 tile');

    var start = makePlayerFromTopRight(tile_size * 2 - 5, tile_size + 5);
    var tried = makePlayerFromTopRight(tile_size * 2 - 10, tile_size + 10);
    var expect = tried;
    addUseCase(
        start,
        [],
        tried,
        expect,
        description
    );

    var description = concatLB(descr_direction, '1 tile to 2');

    var tile = findTile(1,1);
    var start = makePlayerFromTopLeft(tile.x_max + 3, tile.y_min + 5);
    var tried = makePlayerFromTopLeft(tile.x_max - 5, tile.y_min + 10);
    var expect = makePlayerFromTopLeft(tile.x_max + 1, getYOnSegment(tile.x_max + 1, new Position(start.bbox_left, start.bbox_top), new Position(tried.bbox_left, tried.bbox_top)));
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var description = concatLB(descr_direction, '2 tiles to 2');

    var tile = findTile(2,2);
    var start = makePlayerFromBottomRight(tile.x_max + 3, tile.y_min - 5);
    var tried = makePlayerFromBottomRight(tile.x_max - 5, tile.y_min + 3);
    var expect = makePlayerFromBottomRight(getXOnSegment(tile.y_min - 1, new Position(start.bbox_right, start.bbox_bottom), new Position(tried.bbox_right, tried.bbox_bottom)), tile.y_min - 1);
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var description = concatLB(descr_direction, '1 tile to 4');

    var tile = findTile(2,1);
    var start = makePlayerFromBottomLeft(tile.x_max + 5, tile.y_min - 10);
    var tried = makePlayerFromBottomLeft(tile.x_max - 10, tile.y_min + 5);
    var expect = makePlayerFromBottomLeft(getXOnSegment(tile.y_min - 1, new Position(start.bbox_left, start.bbox_bottom), new Position(tried.bbox_left, tried.bbox_bottom)), tile.y_min - 1);
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var description = concatLB(descr_direction, '1 tile to 4 (perfect angle)');

    var tile = findTile(2,1);
    var start = makePlayerFromBottomLeft(tile.x_max + 5, tile.y_min - 5);
    var tried = makePlayerFromBottomLeft(tile.x_max - 5, tile.y_min + 5);
    var expect = makePlayerFromBottomLeft(getXOnSegment(tile.y_min - 1, new Position(start.bbox_left, start.bbox_bottom), new Position(tried.bbox_left, tried.bbox_bottom)), tile.y_min - 1);
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var description = concatLB(descr_direction, '2 tiles to 1 other, CROSSING other tile');

    var tile = findTile(1,1);
    var start = makePlayerFromBottomRight(tile.x_min + 8, tile.y_min - 3);
    var tried = makePlayerFromBottomRight(tile.x_min - 3, tile.y_min + 8);
    var expect = makePlayerFromBottomRight(getXOnSegment(tile.y_min - 1, new Position(start.bbox_right, start.bbox_bottom), new Position(tried.bbox_right, tried.bbox_bottom)), tile.y_min - 1);
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    ///////// DIRECTION = TOP LEFT
    var descr_direction = 'to top left';

    var description = concatLB(descr_direction, 'inside 1 tile');

    var start = makePlayerFromTopRight(tile_size * 2 - 5, tile_size + 10);
    var tried = makePlayerFromTopRight(tile_size * 2 - 10, tile_size + 5);
    var expect = tried;
    addUseCase(
        start,
        [],
        tried,
        expect,
        description
    );

    var description = concatLB(descr_direction, '1 tile to 2');

    var tile = findTile(1,1);
    var start = makePlayerFromTopLeft(tile.x_max + 3, tile.y_min + 10);
    var tried = makePlayerFromTopLeft(tile.x_max - 5, tile.y_min + 5);
    var expect = makePlayerFromTopLeft(tile.x_max + 1, getYOnSegment(tile.x_max + 1, new Position(start.bbox_left, start.bbox_top), new Position(tried.bbox_left, tried.bbox_top)));
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var description = concatLB(descr_direction, '2 tiles to 2');

    var tile = findTile(2,2);
    var start = makePlayerFromTopRight(tile.x_max + 3, tile.y_max + 5);
    var tried = makePlayerFromTopRight(tile.x_max - 5, tile.y_max - 3);
    var expect = makePlayerFromTopRight(getXOnSegment(tile.y_max + 1, new Position(start.bbox_right, start.bbox_top), new Position(tried.bbox_right, tried.bbox_top)), tile.y_max + 1);
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var description = concatLB(descr_direction, '1 tile to 4');

    var tile = findTile(2,1);
    var start = makePlayerFromTopLeft(tile.x_max + 5, tile.y_max + 10);
    var tried = makePlayerFromTopLeft(tile.x_max - 10, tile.y_max - 5);
    var expect = makePlayerFromTopLeft(getXOnSegment(tile.y_max + 1, new Position(start.bbox_left, start.bbox_top), new Position(tried.bbox_left, tried.bbox_top)), tile.y_max + 1);
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var description = concatLB(descr_direction, '1 tile to 4 (perfect angle)');

    var tile = findTile(2,1);
    var start = makePlayerFromTopLeft(tile.x_max + 5, tile.y_max + 5);
    var tried = makePlayerFromTopLeft(tile.x_max - 5, tile.y_max - 5);
    var expect = makePlayerFromTopLeft(getXOnSegment(tile.y_max + 1, new Position(start.bbox_left, start.bbox_top), new Position(tried.bbox_left, tried.bbox_top)), tile.y_max + 1);
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var description = concatLB(descr_direction, '2 tiles to 1 other, CROSSING other tile');

    var tile = findTile(1,2);
    var start = makePlayerFromBottomLeft(tile.x_max + 3, tile.y_min + 8);
    var tried = makePlayerFromBottomLeft(tile.x_max - 8, tile.y_min - 3);
    var expect = makePlayerFromBottomLeft(tile.x_max + 1, getYOnSegment(tile.x_max + 1, new Position(start.bbox_left, start.bbox_bottom), new Position(tried.bbox_left, tried.bbox_bottom)));
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var tile = findTile(2,2);
    var start = makePlayerFromTopRight(tile.x_min + 8, tile.y_max + 3);
    var tried = makePlayerFromTopRight(tile.x_min - 3, tile.y_max - 8);
    var expect = makePlayerFromTopRight(getXOnSegment(tile.y_max + 1, new Position(start.bbox_right, start.bbox_top), new Position(tried.bbox_right, tried.bbox_top)), tile.y_max + 1);
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    ///////// DIRECTION = TOP RIGHT
    var descr_direction = 'to top right';

    var description = concatLB(descr_direction, 'inside 1 tile');

    var start = makePlayerFromTopLeft(tile_size * 2 + 5, tile_size + 10);
    var tried = makePlayerFromTopLeft(tile_size * 2 + 10, tile_size + 5);
    var expect = tried;
    addUseCase(
        start,
        [],
        tried,
        expect,
        description
    );

    var description = concatLB(descr_direction, '1 tile to 2');

    var tile = findTile(2,1);
    var start = makePlayerFromTopRight(tile.x_min - 3, tile.y_min + 10);
    var tried = makePlayerFromTopRight(tile.x_min + 5, tile.y_min + 5);
    var expect = makePlayerFromTopRight(tile.x_min - 1, getYOnSegment(tile.x_min - 1, new Position(start.bbox_right, start.bbox_top), new Position(tried.bbox_right, tried.bbox_top)));
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var description = concatLB(descr_direction, '2 tiles to 2');

    var tile = findTile(2,2);
    var start = makePlayerFromTopLeft(tile.x_min - 3, tile.y_max + 5);
    var tried = makePlayerFromTopLeft(tile.x_min + 5, tile.y_max - 3);
    var expect = makePlayerFromTopLeft(getXOnSegment(tile.y_max + 1, new Position(start.bbox_left, start.bbox_top), new Position(tried.bbox_left, tried.bbox_top)), tile.y_max + 1);
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var description = concatLB(descr_direction, '1 tile to 4');

    var tile = findTile(2,1);
    var start = makePlayerFromTopRight(tile.x_min - 5, tile.y_max + 10);
    var tried = makePlayerFromTopRight(tile.x_min + 10, tile.y_max - 5);
    var expect = makePlayerFromTopRight(getXOnSegment(tile.y_max + 1, new Position(start.bbox_right, start.bbox_top), new Position(tried.bbox_right, tried.bbox_top)), tile.y_max + 1);
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var description = concatLB(descr_direction, '1 tile to 4 (perfect angle)');

    var tile = findTile(2,1);
    var start = makePlayerFromTopRight(tile.x_min - 5, tile.y_max + 5);
    var tried = makePlayerFromTopRight(tile.x_min + 5, tile.y_max - 5);
    var expect = makePlayerFromTopRight(getXOnSegment(tile.y_max + 1, new Position(start.bbox_right, start.bbox_top), new Position(tried.bbox_right, tried.bbox_top)), tile.y_max + 1);
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var description = concatLB(descr_direction, '2 tiles to 1 other, CROSSING other tile');

    var tile = findTile(1,2);
    var start = makePlayerFromBottomRight(tile.x_min - 3, tile.y_min + 8);
    var tried = makePlayerFromBottomRight(tile.x_min + 8, tile.y_min - 3);
    var expect = makePlayerFromBottomRight(tile.x_min - 1, getYOnSegment(tile.x_min - 1, new Position(start.bbox_right, start.bbox_bottom), new Position(tried.bbox_right, tried.bbox_bottom)));
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var tile = findTile(2,2);
    var start = makePlayerFromTopLeft(tile.x_max - 8, tile.y_max + 3);
    var tried = makePlayerFromTopLeft(tile.x_max + 3, tile.y_max - 8);
    var expect = makePlayerFromTopLeft(getXOnSegment(tile.y_max + 1, new Position(start.bbox_left, start.bbox_top), new Position(tried.bbox_left, tried.bbox_top)), tile.y_max + 1);
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    ///////// DIRECTION = TOP ONLY
    var descr_direction = 'to top only';

    var description = concatLB(descr_direction, 'inside 1 tile');

    var start = makePlayerFromTopLeft(tile_size * 2 + 10, tile_size + 10);
    var tried = makePlayerFromTopLeft(start.bbox_left, tile_size + 5);
    var expect = tried;
    addUseCase(
        start,
        [],
        tried,
        expect,
        description
    );

    var description = concatLB(descr_direction, '1 tile to 2 tiles');

    var start = makePlayerFromTopLeft(tile_size * 2 + 10, tile_size + 5);
    var tried = makePlayerFromTopLeft(start.bbox_left, tile_size - 5);
    var expect = tried;
    addUseCase(
        start,
        [],
        tried,
        expect,
        description
    );

    var tile = findTile(2,2);
    var start = makePlayerFromTopLeft(tile.x_min + 10, tile.y_max + 5);
    var tried = makePlayerFromTopLeft(start.bbox_left, tile.y_max - 5);
    var expect = makePlayerFromTopLeft(start.bbox_left, tile.y_max + 1);;
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var description = concatLB(descr_direction, '2 tiles to 4 tiles');

    var tile = findTile(2,2);
    var start = makePlayerFromTopLeft(tile.x_max - 10, tile.y_max + 5);
    var tried = makePlayerFromTopLeft(start.bbox_left, tile.y_max - 5);
    var expect = makePlayerFromTopLeft(start.bbox_left, tile.y_max + 1);
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var tile = findTile(2,2);
    var start = makePlayerFromTopLeft(tile.x_min - 10, tile.y_max + 5);
    var tried = makePlayerFromTopLeft(start.bbox_left, tile.y_max - 5);
    var expect = makePlayerFromTopLeft(start.bbox_left, tile.y_max + 1);
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    ///////// DIRECTION = BOTTOM ONLY
    var descr_direction = 'to bottom only';

    var description = concatLB(descr_direction, 'inside 1 tile');

    var start = makePlayerFromBottomLeft(tile_size * 2 + 10, tile_size * 2 - 10);
    var tried = makePlayerFromBottomLeft(start.bbox_left, tile_size * 2 - 5);
    var expect = tried;
    addUseCase(
        start,
        [],
        tried,
        expect,
        description
    );

    var description = concatLB(descr_direction, '1 tile to 2 tiles');

    var start = makePlayerFromBottomLeft(tile_size * 2 + 10, tile_size * 2 - 5);
    var tried = makePlayerFromBottomLeft(start.bbox_left, tile_size * 2 + 5);
    var expect = tried;
    addUseCase(
        start,
        [],
        tried,
        expect,
        description
    );

    var tile = findTile(2,2);
    var start = makePlayerFromBottomLeft(tile.x_min + 10, tile.y_min - 5);
    var tried = makePlayerFromBottomLeft(start.bbox_left, tile.y_min + 5);
    var expect = makePlayerFromBottomLeft(start.bbox_left, tile.y_min - 1);;
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var description = concatLB(descr_direction, '2 tiles to 4 tiles');

    var tile = findTile(2,2);
    var start = makePlayerFromBottomLeft(tile.x_max - 10, tile.y_min - 5);
    var tried = makePlayerFromBottomLeft(start.bbox_left, tile.y_min + 5);
    var expect = makePlayerFromBottomLeft(start.bbox_left, tile.y_min - 1);
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var tile = findTile(2,2);
    var start = makePlayerFromBottomLeft(tile.x_min - 10, tile.y_min - 5);
    var tried = makePlayerFromBottomLeft(start.bbox_left, tile.y_min + 5);
    var expect = makePlayerFromBottomLeft(start.bbox_left, tile.y_min - 1);
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var description = concatLB(descr_direction, '1 tile to 2 tiles');
    description = concatLB(description, '1px yy');

    var tile = findTile(2,2);
    var start = makePlayerFromBottomLeft(tile.x_min + 10, tile.y_min - 1);
    var tried = makePlayerFromBottomLeft(start.bbox_left, tile.y_min);
    var expect = start;
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    ///////// DIRECTION = RIGHT ONLY
    var descr_direction = 'to right only';

    var description = concatLB(descr_direction, 'inside 1 tile');

    var start = makePlayerFromTopRight(tile_size * 2 - 15, tile_size * 2 + 10);
    var tried = makePlayerFromTopRight(tile_size * 2 - 10, start.bbox_top);
    var expect = tried;
    addUseCase(
        start,
        [],
        tried,
        expect,
        description
    );

    var description = concatLB(descr_direction, '1 tile to 2 tiles');

    var start = makePlayerFromTopRight(tile_size * 2 - 5, tile_size * 2 + 10);
    var tried = makePlayerFromTopRight(tile_size * 2 + 5, start.bbox_top);
    var expect = tried;
    addUseCase(
        start,
        [],
        tried,
        expect,
        description
    );

    var tile = findTile(2,2);
    var start = makePlayerFromTopRight(tile.x_min - 5, tile.y_min + 10);
    var tried = makePlayerFromTopRight(tile.x_min + 5, start.bbox_top);
    var expect = makePlayerFromTopRight(tile.x_min - 1, start.bbox_top);
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var description = concatLB(descr_direction, '2 tiles to 4 tiles');

    var tile = findTile(2,2);
    var start = makePlayerFromTopRight(tile.x_min - 5, tile.y_min - 10);
    var tried = makePlayerFromTopRight(tile.x_min + 5, start.bbox_top);
    var expect = makePlayerFromTopRight(tile.x_min - 1, start.bbox_top);
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var tile = findTile(2,2);
    var start = makePlayerFromTopRight(tile.x_min - 5, tile.y_max - 10);
    var tried = makePlayerFromTopRight(tile.x_min + 5, start.bbox_top);
    var expect = makePlayerFromTopRight(tile.x_min - 1, start.bbox_top);
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    ///////// DIRECTION = LEFT ONLY
    var descr_direction = 'to left only';

    var description = concatLB(descr_direction, 'inside 1 tile');

    var start = makePlayerFromTopLeft(tile_size * 2 + 15, tile_size * 2 + 10);
    var tried = makePlayerFromTopLeft(tile_size * 2 + 10, start.bbox_top);
    var expect = tried;
    addUseCase(
        start,
        [],
        tried,
        expect,
        description
    );

    var description = concatLB(descr_direction, '1 tile to 2 tiles');

    var start = makePlayerFromTopLeft(tile_size * 2 + 5, tile_size * 2 + 10);
    var tried = makePlayerFromTopLeft(tile_size * 2 - 5, start.bbox_top);
    var expect = tried;
    addUseCase(
        start,
        [],
        tried,
        expect,
        description
    );

    var tile = findTile(2,2);
    var start = makePlayerFromTopLeft(tile.x_max + 5, tile.y_min + 10);
    var tried = makePlayerFromTopLeft(tile.x_max - 5, start.bbox_top);
    var expect = makePlayerFromTopLeft(tile.x_max + 1, start.bbox_top);
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var description = concatLB(descr_direction, '2 tiles to 4 tiles');

    var tile = findTile(2,2);
    var start = makePlayerFromTopLeft(tile.x_max + 5, tile.y_min - 10);
    var tried = makePlayerFromTopLeft(tile.x_max - 5, start.bbox_top);
    var expect = makePlayerFromTopLeft(tile.x_max + 1, start.bbox_top);
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

    var tile = findTile(2,2);
    var start = makePlayerFromTopLeft(tile.x_max + 5, tile.y_max - 10);
    var tried = makePlayerFromTopLeft(tile.x_max - 5, start.bbox_top);
    var expect = makePlayerFromTopLeft(tile.x_max + 1, start.bbox_top);
    addUseCase(
        start,
        [tile],
        tried,
        expect,
        description
    );

//*/
    // todo :
    //  - tester les déplacements avec des vecteurs > tile_size
    //  - tester avec un player plus large ou haut que tile_size

}






// #####################################################################
// ################## Use Case Functions ###############################
// #####################################################################

/**
 * Add a use case to test.
 * @param {Player} player - The player starting state 
 * @param {Tile[]} collision_tiles - Some collision tiles
 * @param {(Player|Position)} tried_position - Where the player tries to go. You can use a Position or a Player. Only x and y are used.
 * @param {(Player|Position)} expected_position - Where the player should be after the collision check.
 * @param {string} description
 */
function addUseCase(player, collision_tiles, tried_position, expected_position, description = '') {
    use_case_count++;

    var res = _testScript(player, collision_tiles, tried_position);

    var final_position = new Position(res.final_pos_arr[0], res.final_pos_arr[1]);

    var is_success = _isSamePosition(final_position, expected_position);
    if (!is_success) _fail_count++;

    _drawUseCase(player, collision_tiles, tried_position, expected_position, final_position, is_success, res.tilemap_get_at_pixel_call, description);
}

/**
 * Player object
 */
function Player(x, y, bbox_left, bbox_top, bbox_right, bbox_bottom) {
    this.x = x;
    this.y = y;
    this.bbox_left = bbox_left;
    this.bbox_top = bbox_top;
    this.bbox_right = bbox_right;
    this.bbox_bottom = bbox_bottom;

    this.width = () => this.bbox_right - this.bbox_left;
    this.height = () => this.bbox_bottom - this.bbox_top;
}

/**
 * Let say the player looks like this :
 * ---------
 * |       |
 * |       |
 * |       |
 * |   *   |
 * ---------
 * Where the "*" is the origin (x, y) and the rectangle is the bbox.
 * You can get it from one of his corner. With one of the following functions.
 * @param {number} corner_x
 * @param {number} corner_y
 * @param {number} bbox_width
 * @param {number} bbox_height
 * @returns {Player}
 */
function makePlayerFromTopLeft(bbox_top_left_corner_x, bbox_top_left_corner_y, bbox_width = 32, bbox_height = 48) {
    return new Player(
        bbox_top_left_corner_x + Math.round(bbox_width/2),
        bbox_top_left_corner_y + Math.round(bbox_height/1.25),
        bbox_top_left_corner_x,
        bbox_top_left_corner_y,
        bbox_top_left_corner_x + bbox_width,
        bbox_top_left_corner_y + bbox_height
    );
}
function makePlayerFromTopRight(bbox_top_right_corner_x, bbox_top_right_corner_y, bbox_width = 32, bbox_height = 48) {
    return new Player(
        bbox_top_right_corner_x - Math.round(bbox_width/2),
        bbox_top_right_corner_y + Math.round(bbox_height/1.25),
        bbox_top_right_corner_x - bbox_width,
        bbox_top_right_corner_y,
        bbox_top_right_corner_x,
        bbox_top_right_corner_y + bbox_height
    );
}
function makePlayerFromBottomLeft(bbox_bottom_left_corner_x, bbox_bottom_left_corner_y, bbox_width = 32, bbox_height = 48) {
    return new Player(
        bbox_bottom_left_corner_x + Math.round(bbox_width/2),
        bbox_bottom_left_corner_y - bbox_height + Math.round(bbox_height/1.25),
        bbox_bottom_left_corner_x,
        bbox_bottom_left_corner_y - bbox_height,
        bbox_bottom_left_corner_x + bbox_width,
        bbox_bottom_left_corner_y
    );
}
function makePlayerFromBottomRight(bbox_bottom_right_corner_x, bbox_bottom_right_corner_y, bbox_width = 32, bbox_height = 48) {
    return new Player(
        bbox_bottom_right_corner_x - Math.round(bbox_width/2),
        bbox_bottom_right_corner_y - bbox_height + Math.round(bbox_height/1.25),
        bbox_bottom_right_corner_x - bbox_width,
        bbox_bottom_right_corner_y - bbox_height,
        bbox_bottom_right_corner_x,
        bbox_bottom_right_corner_y
    );
}

/**
 * A Tile.
 * Use findTile() to get a proper tile.
 */
function Tile(x_min, x_max, y_min, y_max) {
    this.x_min = x_min;
    this.x_max = x_max;
    this.y_min = y_min;
    this.y_max = y_max;
    this.id = 1;
    this.width = () => this.x_max - this.x_min;
    this.height = () => this.x_max - this.x_min;
}

/**
 * Get a tile by its position on the grid. The top left tile is (0,0), right to it is (1,0), under this one is (1,1) etc.
 */
function findTile(horizontal_nb, vertical_nb) {
    var x_min = horizontal_nb * tile_size;
    var y_min = vertical_nb * tile_size;
    return new Tile(x_min, x_min + tile_size - 1, y_min, y_min + tile_size - 1);
}

function Position(x, y) {
    this.x = x;
    this.y = y;
}

/**
 * Concat strings with line breaks
 */
function concatLB(...lines) {
    return lines.join('<br>');
}

/**
 * @see https://math.stackexchange.com/questions/2297518/find-x-value-on-a-line-segment-with-given-y
 * @param {number} point_y - Y coordinate of the point
 * @param {(Player|Position)} position1 - One of the vector end
 * @param {(Player|Position)} position2 - The other vector end
 * @returns {number} point_x
 */
function getXOnSegment(point_y, position1, position2) {
	if (position1.x == position2.x) return position1.x;
    return position1.x + ( ( (point_y - position1.y) * (position2.x - position1.x) ) / (position2.y - position1.y) );
}

/**
 * @see https://math.stackexchange.com/questions/2297518/find-x-value-on-a-line-segment-with-given-y
 * @param {number} point_x - X coordinate of the point
 * @param {(Player|Position)} position1 - One of the vector end
 * @param {(Player|Position)} position2 - The other vector end
 * @returns {number} point_y
 */
function getYOnSegment(point_x, position1, position2) {
	if (position1.y == position2.y) return position1.y;
    return position1.y + ( ( (point_x - position1.x) * (position2.y - position1.y) ) / (position2.x - position1.x) );
}

/**
 * @see https://mathinsight.org/definition/magnitude_vector
 */
function getVectorMagnitude(position1, position2) {
	return Math.sqrt(Math.pow(position1.x - position2.x, 2) + Math.pow(position1.y - position2.y, 2));
}










// #####################################################################
// ################## Private Functions ###############################
// #####################################################################

/**
 * Run getValidPosition()
 */
function _testScript(player, collision_tiles, tried_position) {
    var tilemap_get_at_pixel_call = 0;
    var tilemap_get_at_pixel = function(tilemap, x, y) {
        tilemap_get_at_pixel_call++;
        var res = collision_tiles.find((tile) => {
            if (x >= tile.x_min && x <= tile.x_max &&
                y >= tile.y_min && y <= tile.y_max) {
                return true; // colliding
            }
            return false;
        });
        return res ? res.id : 0;
    }
    var final_pos_arr = getValidPosition(player.x, player.y, tried_position.x - player.x, tried_position.y - player.y, player.bbox_left, player.bbox_top, player.bbox_right, player.bbox_bottom, tilemap_get_at_pixel, tile_size, room_width, room_height);
    return {final_pos_arr: final_pos_arr, tilemap_get_at_pixel_call: tilemap_get_at_pixel_call};
}

function _drawUseCase(player, collision_tiles, tried_position, expected_position, final_position, is_success, tilemap_get_at_pixel_call, description = '') {

    // get Players from Positions
    var tried_player = _getPlayerAt(player, tried_position);
    var expected_player = _getPlayerAt(player, expected_position);
    var final_player = _getPlayerAt(player, final_position);

    var status_line_width = 5;

    var container = document.createElement('div');
    container.id = 'useCase' + use_case_count;
    container.appendChild(_getReport(player, collision_tiles, tried_player, expected_player, final_player, is_success, tilemap_get_at_pixel_call, description));

    container.className = 'use-case';
    var canvas = document.createElement('canvas');

    var bounds = this._getBounds(player, collision_tiles, tried_player, expected_player, final_player);

    // center (square canvas only)
    var bounds_width = bounds.x_max - bounds.x_min;
    var bounds_height = bounds.y_max - bounds.y_min;
    if (bounds_width > bounds_height) {
        // vertical
        bounds = _boundsAddMargin(bounds, 0, (bounds_width - bounds_height) / 2);
    } else {
        // horizontal
        bounds = _boundsAddMargin(bounds, (bounds_height - bounds_width) / 2, 0);
    }

    // some margins
    bounds = _boundsAddMargin(bounds, _canvas_margin, _canvas_margin);

    // apply zoom
    if (zoom != 0) {
        if (zoom > 0) {
            zoom_margin = (bounds.width() - (bounds.width() / (zoom + 1))) / 2 * -1;
        } else {
            zoom_margin = ((bounds.width() * (Math.abs(zoom) + 1)) - bounds.width()) / 2;
        }
        bounds = _boundsAddMargin(bounds, zoom_margin,  zoom_margin);
    }

    scale = _canvas_size / Math.max(bounds.x_max - bounds.x_min, bounds.y_max - bounds.y_min);

    canvas.setAttribute('width', _canvas_size);
    canvas.setAttribute('height', _canvas_size);
    var canvas_container = document.createElement('div');
    canvas_container.className = 'canvas-container';
    canvas_container.appendChild(canvas);
    container.appendChild(canvas_container);
    document.getElementById('useCases').appendChild(container);

    var ctx = canvas.getContext('2d');

    // status border
    ctx.strokeStyle = is_success ? _success_color : _fail_color;
    ctx.lineWidth = status_line_width;
    ctx.strokeRect(0, 0, _canvas_size, _canvas_size);

    ctx.scale(scale, scale);
    ctx.translate(-bounds.x_min, -bounds.y_min);

    var canvas_bounds = new _Bounds(
        bounds.x_min,
        bounds.x_min + (_canvas_size/scale),
        bounds.y_min,
        bounds.y_min + (_canvas_size/scale)
    );

    ctx.lineWidth = 1;

    // grid
    grid_bounds = new _Bounds(
        canvas_bounds.x_min + status_line_width,
        canvas_bounds.x_max - status_line_width,
        canvas_bounds.y_min + status_line_width,
        canvas_bounds.y_max - status_line_width
    );
    var font_size = Math.ceil(10 / scale);
    ctx.font = font_size + 'px sans-serif';
    ctx.fillStyle = _coord_font_color;
    ctx.textAlign = 'left';
    // vertical
    ctx.strokeStyle = _grid_color;
    var grid_x = grid_bounds.x_min - (grid_bounds.x_min % tile_size) + tile_size;
    var max_grid_x = grid_bounds.x_max - (grid_bounds.x_max % tile_size);
    for (grid_x; grid_x <= max_grid_x; grid_x += tile_size) {
        ctx.fillText(grid_x, grid_x + 1, grid_bounds.y_min + font_size);
        ctx.globalAlpha = 0.3;
        _drawLine(ctx, new Position(grid_x, grid_bounds.y_min), new Position(grid_x, grid_bounds.y_max));
        ctx.globalAlpha = 1;
    }
    // horizontal
    var grid_y = grid_bounds.y_min - (grid_bounds.y_min % tile_size) + tile_size;
    var max_grid_y = grid_bounds.y_max - (grid_bounds.y_max % tile_size);
    for (grid_y; grid_y <= max_grid_y; grid_y += tile_size) {
        ctx.fillText(grid_y, grid_bounds.x_min, grid_y + font_size);
        ctx.globalAlpha = 0.3;
        _drawLine(ctx, new Position(grid_bounds.x_min, grid_y), new Position(grid_bounds.x_max, grid_y));
        ctx.globalAlpha = 1;
    }

    // collision tiles
    ctx.strokeStyle = _collision_tile_color;
    ctx.globalAlpha = 0.5;
    collision_tiles.forEach((tile) => {
        ctx.strokeRect(tile.x_min, tile.y_min, tile.width(), tile.height());
        _drawLine(ctx, new Position(tile.x_min, tile.y_min), new Position(tile.x_max, tile.y_max));
        _drawLine(ctx, new Position(tile.x_max, tile.y_min), new Position(tile.x_min, tile.y_max));
    });
    ctx.globalAlpha = 1;

    var final_is_tried = _isSamePosition(final_player, tried_player);

    var players_count = 0;

    // player start
    players_count++;
    ctx.strokeStyle = _player_color;
    _drawPlayer(ctx, player);
    _drawPlayerArc(ctx, player, players_count);

    // player tried
    players_count++;
    ctx.strokeStyle = _tried_position_color;
    if (!final_is_tried) {
        _drawPathBetweenPlayers(ctx, player, tried_player);
        _drawPlayer(ctx, tried_player);
    }
    _drawPlayerArc(ctx, tried_player, players_count);

    // player expected
    players_count++;
    ctx.strokeStyle = _expected_position_color;
    _drawPathBetweenPlayers(ctx, player, expected_player);
    _drawPlayer(ctx, expected_player);
    _drawPlayerArc(ctx, expected_player, players_count);

    // player end
    players_count++;
    ctx.strokeStyle = _final_position_color;
    if (!is_success) {
        _drawPathBetweenPlayers(ctx, player, final_player);
        _drawPlayer(ctx, final_player);
    }
    _drawPlayerArc(ctx, final_player, players_count);
}

function _drawPlayerArc(ctx, player, playerId) {
	var parts = 4;
    var arcSize = 2 / parts;
    var radius = 2 + Math.ceil(playerId / parts);
    var arcStart = ( (playerId % parts) + 1 ) * arcSize * Math.PI;
    var arcEnd = arcStart + (arcSize * Math.PI);
    _drawCircle(ctx, player.x, player.y, radius, arcStart, arcEnd);
}

function _boundsAddMargin(bounds, mx, my) {
    return new _Bounds(
        bounds.x_min - mx,
        bounds.x_max + mx,
        bounds.y_min - my,
        bounds.y_max + my
    );
}

function _drawPlayer(ctx, player) {
    ctx.strokeRect(player.bbox_left, player.bbox_top, player.width(), player.height());
    _drawXY(ctx, player.x, player.y);
}

function _drawPathBetweenPlayers(ctx, player1, player2) {
    ctx.setLineDash(_paths_dash);
    ctx.globalAlpha = _paths_alpha;
    if (player1.bbox_left < player2.bbox_left && player1.bbox_top >= player2.bbox_top || player1.bbox_left >= player2.bbox_left && player1.bbox_top < player2.bbox_top)
        _drawLine(ctx, new Position(player1.bbox_left, player1.bbox_top), new Position(player2.bbox_left, player2.bbox_top));
    if (player1.bbox_right <= player2.bbox_right && player1.bbox_top < player2.bbox_top || player1.bbox_right > player2.bbox_right && player1.bbox_top >= player2.bbox_top)
        _drawLine(ctx, new Position(player1.bbox_right, player1.bbox_top), new Position(player2.bbox_right, player2.bbox_top));
    if (player1.bbox_left > player2.bbox_left && player1.bbox_bottom >= player2.bbox_bottom || player1.bbox_left <= player2.bbox_left && player1.bbox_bottom < player2.bbox_bottom)
        _drawLine(ctx, new Position(player1.bbox_left, player1.bbox_bottom), new Position(player2.bbox_left, player2.bbox_bottom));
    if (player1.bbox_right >= player2.bbox_right && player1.bbox_bottom < player2.bbox_bottom || player1.bbox_right < player2.bbox_right && player1.bbox_bottom >= player2.bbox_bottom)
        _drawLine(ctx, new Position(player1.bbox_right, player1.bbox_bottom), new Position(player2.bbox_right, player2.bbox_bottom));
    ctx.setLineDash([]);
    ctx.globalAlpha = 1;
}

function _drawXY(ctx, x, y) {
    _drawLine(ctx, new Position(x, y-2), new Position(x, y+2));
    _drawLine(ctx, new Position(x-2, y), new Position(x+2, y));
}

function _drawLine(ctx, startCoord, endCoord) {
    ctx.beginPath();
    ctx.moveTo(startCoord.x, startCoord.y);
    ctx.lineTo(endCoord.x, endCoord.y);
    ctx.stroke();
}

function _drawCircle(ctx, x, y, radius, start, end) {
    ctx.beginPath();
    ctx.arc(x, y, radius, start, end, false);
    ctx.stroke();
}

function _getPlayerAt(player, position) {
    return new Player(
        position.x,
        position.y,
        position.x - (player.x - player.bbox_left),
        position.y - (player.y - player.bbox_top),
        position.x + (player.bbox_right - player.x),
        position.y + (player.bbox_bottom - player.y)
    );
}

function _getBounds(player, collision_tiles, tried_player, expected_player, final_player) {

    var bounds = _playerToBounds(player);

    /*collision_tiles.forEach((tile) => {
        bounds = _mergeBounds(bounds, new _Bounds(
            tile.x_min,
            tile.x_max,
            tile.y_min,
            tile.y_max
        ));
    });*/

    bounds = _mergeBounds(bounds, _playerToBounds(tried_player));
    bounds = _mergeBounds(bounds, _playerToBounds(expected_player));
    bounds = _mergeBounds(bounds, _playerToBounds(final_player));

    return bounds;
}

function _playerToBounds(player) {
    return new _Bounds(player.bbox_left, player.bbox_right, player.bbox_top, player.bbox_bottom);
}

function _mergeBounds(bounds1, bounds2) {
    return new _Bounds(
        Math.min(bounds1.x_min, bounds2.x_min),
        Math.max(bounds1.x_max, bounds2.x_max),
        Math.min(bounds1.y_min, bounds2.y_min),
        Math.max(bounds1.y_max, bounds2.y_max)
    );
}

function _Bounds(x_min, x_max, y_min, y_max) {
    this.x_min = x_min;
    this.x_max = x_max;
    this.y_min = y_min;
    this.y_max = y_max;
    this.width = function() {
        return this.x_max - this.x_min;
    }
    this.height = function() {
        return this.y_max - this.y_min;
    }
}

function _drawCaption() {

    _drawPlayerCaption('playerCaptionCanvas', _player_color);
    _drawPlayerCaption('triedCaptionCanvas', _tried_position_color);
    _drawPlayerCaption('expectedCaptionCanvas', _expected_position_color);
    _drawPlayerCaption('finalCaptionCanvas', _final_position_color);

    var canvas = document.getElementById('collisionTileCaptionCanvas');
    var w = 25;
    var h = 25;
    canvas.setAttribute('width', w)
    canvas.setAttribute('height', h)
    var ctx = canvas.getContext('2d');
    ctx.strokeStyle = _collision_tile_color;
    ctx.strokeRect(0, 0, w, h);
    _drawLine(ctx, new Position(0, 0), new Position(w, h));
    _drawLine(ctx, new Position(w, 0), new Position(0, h));
}

function _drawPlayerCaption(id, color) {
    var w = 15;
    var h = 25;
    var canvas = document.getElementById(id);
    canvas.setAttribute('width', w)
    canvas.setAttribute('height', h)
    var ctx = canvas.getContext('2d');
    ctx.strokeStyle = color;

    ctx.strokeRect(0, 0, w, h);
    _drawLine(ctx, new Position(w/2, (h/2)-2), new Position(w/2, (h/2)+2));
    _drawLine(ctx, new Position((w/2)-2, h/2), new Position((w/2)+2, h/2));
}

function _getReport(player, collision_tiles, tried_player, expected_player, final_player, is_success, tilemap_get_at_pixel_call, description) {

    var title_el = document.createElement('h2');
    title_el.className = 'report-title';
    title_el.innerHTML = 'Use Case ' + use_case_count;

    var summary_el = document.createElement('div');
    summary_el.className = 'report-summary';
    summary_el.innerHTML = tilemap_get_at_pixel_call + ' calls to tilemap_get_at_pixel';

    var description_el = document.createElement('p');
    description_el.className = 'report-description';
    description_el.innerHTML = description;

    var status_el = document.createElement('div');
    status_el.className = 'report-status ' + (is_success ? 'success' : 'fail');
    status_el.innerHTML = is_success ? 'Success' : 'Fail';
    
    var report_el = document.createElement('div');
    report_el.className = 'report';
    report_el.appendChild(title_el);
    report_el.appendChild(summary_el);
    report_el.appendChild(description_el);
    report_el.appendChild(status_el);
    return report_el;
}

function _isSamePosition(player1, player2) {
    return player1.x === player2.x && player1.y === player2.y;
}

function _clearUseCases() {
    var container = document.getElementById('useCases');
    while (container.firstChild) {
        container.removeChild(container.firstChild);
    }
    use_case_count = 0;
}

function _start() {
    _drawCaption();
    _clearUseCases();
    test();
    if (_fail_count > 0) console.log(_fail_count + ' TESTS FAILED');
    else console.log('100% SUCCESS');
}


var _player_color = '#263bc2';
var _tried_position_color = '#7dbae5';
var _final_position_color = '#eb1c1c';
var _expected_position_color = '#39d64f';
var _collision_tile_color = '#db335c';
var _success_color = '#4be12d';
var _fail_color = '#eb1c1c';
var _grid_color = '#cbcac9';
var _coord_font_color = _grid_color;
var _canvas_size = 350;
var _paths_alpha = 0.3;
var _paths_dash = [];
var _canvas_margin = 20;
var _fail_count = 0;

window.onload = _start;

</script>
</body>
</html>
